#include "cpu.h"

#include "utils.h"

#include "memory.h"

#include "update_flags.h"

#include "input.h"
#include "output.h"

#include <stdlib.h>

//memory: stored in mem.c
//i/o: stored in i/o respectively

CPU* cpu_create(void) {
    CPU* cpu = (CPU*)malloc(sizeof(CPU));
    reset(cpu);

    mem_init();
    load_rom_into_mem();

    input_init();
    output_init();

    return cpu;
}

void cpu_destroy(CPU* cpu) {
    free(cpu);
    cpu = NULL;
}

void cpu_reset(CPU* cpu) {
    if (cpu) {
        cpu->A = 0;
        cpu->B = cpu->C = 0;
        cpu->D = cpu->E = 0;
        cpu->H = cpu->L = 0;
        cpu->SP = 0;
        cpu->PC = 0;
        cpu->flags.Z = cpu->flags.S = cpu->flags.P = cpu->flags.CY = cpu->flags.AC = 0;
        cpu->interrupt_enable = 0;
        cpu->cycles = 0;
    }
}

void emulate_8080(CPU *cpu) {/*
    while (1) {
        // Fetch, decode, and execute the next instruction
        execute_instruction(cpu);
        
        // Handle user inputs (e.g., movement, shooting)
        handle_input(cpu);
        
        // Update the display to reflect any changes in the game
        render_display(cpu);
        
        // Optionally: Handle sound and timing
        // sound_emulation(cpu);
        // sleep_for_frame();
    }
    */
}

uint8_t cpu_execute_instruction(CPU* cpu) {
    
    char *opcode = read_memory(cpu->PC);
    uint16_t opcode_size = 1;           //default bytes taken by instruction

    switch (*opcode) {
        case 0x00:          //NOP
            break;
        case 0x01:          //LXI B, D16
            cpu->C = read_memory(cpu->PC + 1);
            cpu->B = read_memory(cpu->PC + 2);
            opcode_size = 3;
            break;
        case 0x02:          //STAX B
             uint16_t address = (cpu->B << 8) | cpu->C;
             write_memory(address, cpu->A);
            break;
        case 0x03:          //INX B
            uint16_t value = ((cpu->B << 8) | cpu->C)+1; 
            cpu->C = value;
            cpu->B = value>>8;
            break;
        case 0x04:          //INR B
            cpu->B += 1;
            update_byte_SZAP(cpu, cpu->B);
            break;
        case 0x05:          //DCR B
            cpu->B -= 1;
			update_byte_SZAP(cpu, cpu->B);
            break;
        case 0x06:          //MVI B, D8      
            cpu->B = read_memory(cpu->PC + 1);
            opcode_size = 2;
            break;
        case 0x07:          //RLC
            cpu->flags->CY = (cpu->A >> 7) & 1;
            cpu->A = (cpu->A << 1) | cpu->flags->CY;
            break;
        case 0x08:          //*NOP
            break;
        case 0x09:          // DAD B (Add BC to HL)
            uint16_t hl = (cpu->H<<8) + cpu->L;
            uint16_t bc = (cpu->B<<8) + cpu->C;
            uint32_t value = hl + bc;
            update_word_CY(value);
            cpu->H = (value >> 8) & 0xff;
            cpu->L = value & 0xff;
            break;
        case 0x0A:          // LDAX B (Load A from address in BC)
            uint16_t address =  (cpu->B<<8) + cpu->C;
            cpu->A = read_memory(address);
            break;
                case 0x0B:          // DCX B
            uint16_t bc = (cpu->B << 8) | cpu->C;
            bc -= 1;
            cpu->B = (bc >> 8) & 0xff;
            cpu->C = bc & 0xff;
            break;
        case 0x0C:          // INR C
            cpu->C += 1;
            update_byte_SZAP(cpu, cpu->C);
            break;
        case 0x0D:          // DCR C
            cpu->C -= 1;
            update_byte_SZAP(cpu, cpu->C);
            break;
        case 0x0E:          // MVI C, D8
            cpu->C = read_memory(cpu->PC + 1);
            opcode_size = 2;
            break;
        case 0x0F:          // RRC
            cpu->flags->CY = cpu->A & 0x01;
            cpu->A = (cpu->A >> 1) | (cpu->flags->CY << 7);
            break;
        case 0x11:          // LXI D, D16
            cpu->E = read_memory(cpu->PC + 1);
            cpu->D = read_memory(cpu->PC + 2);
            opcode_size = 3;
            break;
        case 0x12:          // STAX D
            uint16_t address = (cpu->D << 8) | cpu->E;
            write_memory(address, cpu->A);
            break;
        case 0x13:          // INX D
            uint16_t value = (cpu->D << 8) | cpu->E;
            value += 1;
            cpu->E = value & 0xff;
            cpu->D = (value >> 8) & 0xff;
            break;
        case 0x14:          // INR D
            cpu->D += 1;
            update_byte_SZAP(cpu, cpu->D);
            break;
        case 0x15:          // DCR D
            cpu->D -= 1;
            update_byte_SZAP(cpu, cpu->D);
            break;
        case 0x16:          // MVI D, D8
            cpu->D = read_memory(cpu->PC + 1);
            opcode_size = 2;
            break;
        case 0x17:          // RAL
            uint8_t bit7 = (cpu->A >> 7) & 1;
            uint8_t bit0 = cpu->flags->CY;
            cpu->A = (cpu->A << 1) | bit0;
            cpu->flags->CY = bit7;
            break;
        case 0x18:          //*NOP
            break;
        case 0x19:          // DAD D
            uint32_t hl = (cpu->H << 8) | cpu->L;
            uint32_t de = (cpu->D << 8) | cpu->E;
            uint32_t result = hl + de;
            update_word_CY(cpu, result);
            cpu->H = (result >> 8) & 0xff;
            cpu->L = result & 0xff;
            break;
        case 0x1A:          // LDAX D
            uint16_t address = (cpu->D << 8) | cpu->E;
            cpu->A = read_memory(address);
            break;
        case 0x1B:          // DCX D
            uint16_t de = (cpu->D << 8) | cpu->E;
            de -= 1;
            cpu->D = (de >> 8) & 0xff;
            cpu->E = de & 0xff;
            break;
        case 0x1C:          // INR E
            cpu->E += 1;
            update_byte_SZAP(cpu, cpu->E);
            break;
        case 0x1D:          // DCR E
            cpu->E -= 1;
            update_byte_SZAP(cpu, cpu->E);
            break;
        case 0x1E:          // MVI E, D8
            cpu->E = read_memory(cpu->PC + 1);
            opcode_size = 2;
            break;
        case 0x1F:          // RAR
            uint8_t bit0 = cpu->A & 1;
            uint8_t bit7 = cpu->flags->CY;
            cpu->A = (cpu->A >> 1) | (bit7 << 7);
            cpu->flags->CY = bit0;
            break;



           case 0x21:          // LXI H, D16
            cpu->H = read_memory(cpu->PC + 2);
            cpu->L = read_memory(cpu->PC + 1);
            opcode_size = 3;
            break;
        case 0x22:          // SHLD
            uint16_t address = read_opcode_data_word();
            write_memory(address, cpu->L);
            write_memory(address + 1, cpu->H);
            opcode_size = 3;
            break;
        case 0x23:          // INX H
            uint16_t value = (cpu->H << 8) | cpu->L;
            value += 1;
            cpu->H = (value >> 8) & 0xff;
            cpu->L = value & 0xff;
            break;
        case 0x24:          // INR H
            cpu->H += 1;
            update_byte_SZAP(cpu, cpu->H);
            break;
        case 0x25:          // DCR H
            cpu->H -= 1;
            update_byte_SZAP(cpu, cpu->H);
            break;
        case 0x26:          // MVI H, D8
            cpu->H = read_memory(cpu->PC + 1);
            opcode_size = 2;
            break;
        case 0x27:          // DAA
            if ((cpu->A & 0x0f) > 9)
                cpu->A += 6;
            if (cpu->flags->CY || ((cpu->A & 0xf0) > 0x90)) {
                cpu->A += 0x60;
                cpu->flags->CY = 1;
            }
            update_byte_SZAP(cpu, cpu->A);
            break;
        case 0x29:          // DAD H
            uint32_t hl = (cpu->H << 8) | cpu->L;
            uint32_t result = hl + hl;
            update_word_CY(cpu, result);
            cpu->H = (result >> 8) & 0xff;
            cpu->L = result & 0xff;
            break;
        case 0x2A:          // LHLD
            address = read_opcode_data_word();
            cpu->L = read_memory(address);
            cpu->H = read_memory(address + 1);
            opcode_size = 3;
            break;
        case 0x2B:          // DCX H
            value = (cpu->H << 8) | cpu->L;
            value -= 1;
            cpu->H = (value >> 8) & 0xff;
            cpu->L = value & 0xff;
            break;
        case 0x2C:          // INR L
            cpu->L += 1;
            update_byte_SZAP(cpu, cpu->L);
            break;
        case 0x2D:          // DCR L
            cpu->L -= 1;
            update_byte_SZAP(cpu, cpu->L);
            break;
        case 0x2E:          // MVI L, D8
            cpu->L = read_memory(cpu->PC + 1);
            opcode_size = 2;
            break;
        case 0x2F:          // CMA
            cpu->A = ~cpu->A;
            break;
        case 0x31:          // LXI SP, D16
            cpu->SP = read_opcode_data_word();
            opcode_size = 3;
            break;
        case 0x32:          // STA adr
            address = read_opcode_data_word();
            write_memory(address, cpu->A);
            opcode_size = 3;
            break;
        case 0x33:          // INX SP
            cpu->SP += 1;
            break;
        case 0x34:          // INR M
            address = (cpu->H << 8) | cpu->L;
            value = read_memory(address);
            value += 1;
            update_byte_SZAP(cpu, value);
            write_memory(address, value & 0xff);
            break;
        case 0x35:          // DCR M
            address = (cpu->H << 8) | cpu->L;
            value = read_memory(address);
            value -= 1;
            update_byte_SZAP(cpu, value);
            write_memory(address, value & 0xff);
            break;
        case 0x36:          // MVI M, D8
            value = read_memory(cpu->PC + 1);
            address = (cpu->H << 8) | cpu->L;
            write_memory(address, value);
            opcode_size = 2;
            break;
        case 0x37:          // STC
            cpu->flags->CY = 1;
            break;
        case 0x39:          // DAD SP
            result = ((cpu->H << 8) | cpu->L) + cpu->SP;
            update_word_CY(cpu, result);
            cpu->H = (result >> 8) & 0xff;
            cpu->L = result & 0xff;
            break;
        case 0x3A:          // LDA word
            address = read_opcode_data_word();
            cpu->A = read_memory(address);
            opcode_size = 3;
            break;
        case 0x3B:          // DCX SP
            cpu->SP -= 1;
            break;
        case 0x3C:          // INR A
            cpu->A += 1;
            update_byte_SZAP(cpu, cpu->A);
            break;
        case 0x3D:          // DCR A
            cpu->A -= 1;
            update_byte_SZAP(cpu, cpu->A);
            break;
        case 0x3E:          // MVI A, byte
            cpu->A = read_memory(cpu->PC + 1);
            opcode_size = 2;
            break;
        case 0x3F:          // CMC
            cpu->flags->CY = 1 - cpu->flags->CY;
            break;


        case 0x41:          // MOV B,C (Move C to B)
            cpu->B = cpu->C;
            break;
        case 0x42:          // MOV B,D (Move D to B)
            cpu->B = cpu->D;
            break;
        case 0x43:          // MOV B,E (Move E to B)
            cpu->B = cpu->E;
            break;
        case 0x44:          // MOV B,H (Move H to B)
            cpu->B = cpu->H;
            break;
        case 0x45:          // MOV B,L (Move L to B)
            cpu->B = cpu->L;
            break;
        case 0x46:          // MOV B,M (Move memory at HL to B)
            uint16_t address = (cpu->H << 8) | cpu->L;
            cpu->B = read_memory(address);
            break;
        case 0x47:          // MOV B,A (Move A to B)
            cpu->B = cpu->A;
            break;
        case 0x48:          // MOV C,B (Move B to C)
            cpu->C = cpu->B;
            break;
        case 0x4A:          // MOV C,D (Move D to C)
            cpu->C = cpu->D;
            break;
        case 0x4B:          // MOV C,E (Move E to C)
            cpu->C = cpu->E;
            break;
        case 0x4C:          // MOV C,H (Move H to C)
            cpu->C = cpu->H;
            break;
        case 0x4D:          // MOV C,L (Move L to C)
            cpu->C = cpu->L;
            break;
        case 0x4E:          // MOV C,M (Move memory at HL to C)
            uint16_t address = (cpu->H << 8) | cpu->L;
            cpu->C = read_memory(address);
            break;
        case 0x4F:          // MOV C,A (Move A to C)
            cpu->C = cpu->A;
            break;
        case 0x50:          // MOV D,B (Move B to D)
            cpu->D = cpu->B;
            break;
        case 0x51:          // MOV D,C (Move C to D)
            cpu->D = cpu->C;
            break;
        case 0x53:          // MOV D,E (Move E to D)
            cpu->D = cpu->E;
            break;
        case 0x54:          // MOV D,H (Move H to D)
            cpu->D = cpu->H;
            break;
        case 0x55:          // MOV D,L (Move L to D)
            cpu->D = cpu->L;
            break;
        case 0x56:          // MOV D,M (Move memory at HL to D)
            uint16_t address = (cpu->H << 8) | cpu->L;
            cpu->D = read_memory(address);
            break;
        case 0x57:          // MOV D,A (Move A to D)
            cpu->D = cpu->A;
            break;
        case 0x58:          // MOV E,B (Move B to E)
            cpu->E = cpu->B;
            break;
        case 0x59:          // MOV E,C (Move C to E)
            cpu->E = cpu->C;
            break;
        case 0x5A:          // MOV E,D (Move D to E)
            cpu->E = cpu->D;
            break;
        case 0x5C:          // MOV E,H (Move H to E)
            cpu->E = cpu->H;
            break;
        case 0x5D:          // MOV E,L (Move L to E)
            cpu->E = cpu->L;
            break;
        case 0x5E:          // MOV E,M (Move memory at HL to E)
            uint16_t address = (cpu->H << 8) | cpu->L;
            cpu->E = read_memory(address);
            break;
        case 0x5F:          // MOV E,A (Move A to E)
            cpu->E = cpu->A;
            break;
        case 0x60:          // MOV H,B (Move B to H)
            cpu->H = cpu->B;
            break;
        case 0x61:          // MOV H,C (Move C to H)
            cpu->H = cpu->C;
            break;
        case 0x62:          // MOV H,D (Move D to H)
            cpu->H = cpu->D;
            break;
        case 0x63:          // MOV H,E (Move E to H)
            cpu->H = cpu->E;
            break;
        case 0x65:          // MOV H,L (Move L to H)
            cpu->H = cpu->L;
            break;
        case 0x66:          // MOV H,M (Move memory at HL to H)
            uint16_t address = (cpu->H << 8) | cpu->L;
            cpu->H = read_memory(address);
            break;
        case 0x67:          // MOV H,A (Move A to H)
            cpu->H = cpu->A;
            break;
        case 0x68:          // MOV L,B (Move B to L)
            cpu->L = cpu->B;
            break;
        case 0x69:          // MOV L,C (Move C to L)
            cpu->L = cpu->C;
            break;
        case 0x6A:          // MOV L,D (Move D to L)
            cpu->L = cpu->D;
            break;
        case 0x6B:          // MOV L,E (Move E to L)
            cpu->L = cpu->E;
            break;
        case 0x6C:          // MOV L,H (Move H to L)
            cpu->L = cpu->H;
            break;
        case 0x6E:          // MOV L,M (Move memory at HL to L)
            uint16_t address = (cpu->H << 8) | cpu->L;
            cpu->L = read_memory(address);
            break;
        case 0x6F:          // MOV L,A (Move A to L)
            cpu->L = cpu->A;
            break;




        case 0x70:          // MOV M,B (Move B to memory at HL)
            uint16_t address = (cpu->H << 8) | cpu->L;
            write_memory(address, cpu->B);
            break;
        case 0x71:          // MOV M,C (Move C to memory at HL)
            uint16_t address = (cpu->H << 8) | cpu->L;
            write_memory(address, cpu->C);
            break;
        case 0x72:          // MOV M,D (Move D to memory at HL)
            uint16_t address = (cpu->H << 8) | cpu->L;
            write_memory(address, cpu->D);
            break;
        case 0x73:          // MOV M,E (Move E to memory at HL)
            uint16_t address = (cpu->H << 8) | cpu->L;
            write_memory(address, cpu->E);
            break;
        case 0x74:          // MOV M,H (Move H to memory at HL)
            uint16_t address = (cpu->H << 8) | cpu->L;
            write_memory(address, cpu->H);
            break;
        case 0x75:          // MOV M,L (Move L to memory at HL)
            uint16_t address = (cpu->H << 8) | cpu->L;
            write_memory(address, cpu->L);
            break;
        case 0x77:          // MOV M,A (Move A to memory at HL)
            uint16_t address = (cpu->H << 8) | cpu->L;
            write_memory(address, cpu->A);
            break;
        case 0x78:          // MOV A,B (Move B to A)
            cpu->A = cpu->B;
            break;
        case 0x79:          // MOV A,C (Move C to A)
            cpu->A = cpu->C;
            break;
        case 0x7A:          // MOV A,D (Move D to A)
            cpu->A = cpu->D;
            break;
        case 0x7B:          // MOV A,E (Move E to A)
            cpu->A = cpu->E;
            break;
        case 0x7C:          // MOV A,H (Move H to A)
            cpu->A = cpu->H;
            break;
        case 0x7D:          // MOV A,L (Move L to A)
            cpu->A = cpu->L;
            break;
        case 0x7E:          // MOV A,M (Move memory at HL to A)
            uint16_t address = (cpu->H << 8) | cpu->L;
            cpu->A = read_memory(address);
            break;
        case 0x80:          // ADD B (Add B to A)
            uint16_t answer = (uint16_t)cpu->A + (uint16_t)cpu->B;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x81:          // ADD C (Add C to A)
            uint16_t answer = (uint16_t)cpu->A + (uint16_t)cpu->C;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x82:          // ADD D (Add D to A)
            uint16_t answer = (uint16_t)cpu->A + (uint16_t)cpu->D;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x83:          // ADD E (Add E to A)
            uint16_t answer = (uint16_t)cpu->A + (uint16_t)cpu->E;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x84:          // ADD H (Add H to A)
            uint16_t answer = (uint16_t)cpu->A + (uint16_t)cpu->H;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x85:          // ADD L (Add L to A)
            uint16_t answer = (uint16_t)cpu->A + (uint16_t)cpu->L;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x86:          // ADD M (Add memory at HL to A)
            uint16_t address = (cpu->H << 8) | cpu->L;
            uint16_t answer = (uint16_t)cpu->A + (uint16_t)read_memory(address);
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x87:          // ADD A (Add A to A)
            uint16_t answer = (uint16_t)cpu->A + (uint16_t)cpu->A;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x88:          // ADC B (Add B to A with carry)
            uint16_t value = cpu->A + (uint16_t)cpu->B + cpu->flags->CY;
            update_byte_CY(cpu, value);
            update_byte_SZAP(cpu, value);
            cpu->A = value & 0xff;
            break;
        case 0x89:          // ADC C (Add C to A with carry)
            uint16_t value = cpu->A + (uint16_t)cpu->C + cpu->flags->CY;
            update_byte_CY(cpu, value);
            update_byte_SZAP(cpu, value);
            cpu->A = value & 0xff;
            break;
        case 0x8A:          // ADC D (Add D to A with carry)
            uint16_t value = cpu->A + (uint16_t)cpu->D + cpu->flags->CY;
            update_byte_CY(cpu, value);
            update_byte_SZAP(cpu, value);
            cpu->A = value & 0xff;
            break;
        case 0x8B:          // ADC E (Add E to A with carry)
            uint16_t value = cpu->A + (uint16_t)cpu->E + cpu->flags->CY;
            update_byte_CY(cpu, value);
            update_byte_SZAP(cpu, value);
            cpu->A = value & 0xff;
            break;
        case 0x8C:          // ADC H (Add H to A with carry)
            uint16_t value = cpu->A + (uint16_t)cpu->H + cpu->flags->CY;
            update_byte_CY(cpu, value);
            update_byte_SZAP(cpu, value);
            cpu->A = value & 0xff;
            break;
        case 0x8D:          // ADC L (Add L to A with carry)
            uint16_t value = cpu->A + (uint16_t)cpu->L + cpu->flags->CY;
            update_byte_CY(cpu, value);
            update_byte_SZAP(cpu, value);
            cpu->A = value & 0xff;
            break;
        case 0x8E:          // ADC M (Add memory at HL to A with carry)
            uint16_t address = (cpu->H << 8) | cpu->L;
            uint16_t value = cpu->A + (uint16_t)read_memory(address) + cpu->flags->CY;
            update_byte_CY(cpu, value);
            update_byte_SZAP(cpu, value);
            cpu->A = value & 0xff;
            break;
        case 0x8F:          // ADC A (Add A to A with carry)
            uint16_t value = cpu->A + (uint16_t)cpu->A + cpu->flags->CY;
            update_byte_CY(cpu, value);
            update_byte_SZAP(cpu, value);
            cpu->A = value & 0xff;
            break;




        case 0x90:          // SUB B (Subtract B from A)
            uint16_t answer = (uint16_t)cpu->A - (uint16_t)cpu->B;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x91:          // SUB C (Subtract C from A)
            uint16_t answer = (uint16_t)cpu->A - (uint16_t)cpu->C;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x92:          // SUB D (Subtract D from A)
            uint16_t answer = (uint16_t)cpu->A - (uint16_t)cpu->D;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x93:          // SUB E (Subtract E from A)
            uint16_t answer = (uint16_t)cpu->A - (uint16_t)cpu->E;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x94:          // SUB H (Subtract H from A)
            uint16_t answer = (uint16_t)cpu->A - (uint16_t)cpu->H;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x95:          // SUB L (Subtract L from A)
            uint16_t answer = (uint16_t)cpu->A - (uint16_t)cpu->L;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x96:          // SUB M (Subtract memory at HL from A)
            uint16_t address = (cpu->H << 8) | cpu->L;
            uint16_t answer = (uint16_t)cpu->A - (uint16_t)read_memory(address);
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x97:          // SUB A (Subtract A from A)
            uint16_t answer = (uint16_t)cpu->A - (uint16_t)cpu->A;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x98:          // SBB B (Subtract B from A with borrow)
            uint16_t answer = (uint16_t)cpu->A - (uint16_t)cpu->B - cpu->flags->CY;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x99:          // SBB C (Subtract C from A with borrow)
            uint16_t answer = (uint16_t)cpu->A - (uint16_t)cpu->C - cpu->flags->CY;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x9A:          // SBB D (Subtract D from A with borrow)
            uint16_t answer = (uint16_t)cpu->A - (uint16_t)cpu->D - cpu->flags->CY;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x9B:          // SBB E (Subtract E from A with borrow)
            uint16_t answer = (uint16_t)cpu->A - (uint16_t)cpu->E - cpu->flags->CY;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x9C:          // SBB H (Subtract H from A with borrow)
            uint16_t answer = (uint16_t)cpu->A - (uint16_t)cpu->H - cpu->flags->CY;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x9D:          // SBB L (Subtract L from A with borrow)
            uint16_t answer = (uint16_t)cpu->A - (uint16_t)cpu->L - cpu->flags->CY;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x9E:          // SBB M (Subtract memory at HL from A with borrow)
            uint16_t address = (cpu->H << 8) | cpu->L;
            uint16_t answer = (uint16_t)cpu->A - (uint16_t)read_memory(address) - cpu->flags->CY;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0x9F:          // SBB A (Subtract A from A with borrow)
            uint16_t answer = (uint16_t)cpu->A - (uint16_t)cpu->A - cpu->flags->CY;
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            break;
        case 0xA0:          // ANA B (AND B with A)
            cpu->A &= cpu->B;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xA1:          // ANA C (AND C with A)
            cpu->A &= cpu->C;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xA2:          // ANA D (AND D with A)
            cpu->A &= cpu->D;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xA3:          // ANA E (AND E with A)
            cpu->A &= cpu->E;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xA4:          // ANA H (AND H with A)
            cpu->A &= cpu->H;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xA5:          // ANA L (AND L with A)
            cpu->A &= cpu->L;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xA6:          // ANA M (AND memory at HL with A)
            uint16_t address = (cpu->H << 8) | cpu->L;
            cpu->A &= read_memory(address);
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xA7:          // ANA A (AND A with A)
            cpu->A &= cpu->A;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xA8:          // XRA B (XOR B with A)
            cpu->A ^= cpu->B;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xA9:          // XRA C (XOR C with A)
            cpu->A ^= cpu->C;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xAA:          // XRA D (XOR D with A)
            cpu->A ^= cpu->D;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xAB:          // XRA E (XOR E with A)
            cpu->A ^= cpu->E;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xAC:          // XRA H (XOR H with A)
            cpu->A ^= cpu->H;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xAD:          // XRA L (XOR L with A)
            cpu->A ^= cpu->L;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xAE:          // XRA M (XOR memory at HL with A)
            uint16_t address = (cpu->H << 8) | cpu->L;
            cpu->A ^= read_memory(address);
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xAF:          // XRA A (XOR A with A)
            cpu->A ^= cpu->A;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xB0:          // ORA B (OR B with A)
            cpu->A |= cpu->B;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xB1:          // ORA C (OR C with A)
            cpu->A |= cpu->C;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xB2:          // ORA D (OR D with A)
            cpu->A |= cpu->D;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xB3:          // ORA E (OR E with A)
            cpu->A |= cpu->E;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xB4:          // ORA H (OR H with A)
            cpu->A |= cpu->H;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xB5:          // ORA L (OR L with A)
            cpu->A |= cpu->L;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xB6:          // ORA M (OR memory at HL with A)
            uint16_t address = (cpu->H << 8) | cpu->L;
            cpu->A |= read_memory(address);
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xB7:          // ORA A (OR A with A)
            cpu->A |= cpu->A;
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            break;
        case 0xB8:          // CMP B (Compare A with B)
            uint16_t value = (uint16_t)cpu->A - (uint16_t)cpu->B;
            update_byte_SZAP(cpu, value);
            update_byte_CY(cpu, value);
            break;
        case 0xB9:          // CMP C (Compare A with C)
            uint16_t value = (uint16_t)cpu->A - (uint16_t)cpu->C;
            update_byte_SZAP(cpu, value);
            update_byte_CY(cpu, value);
            break;
        case 0xBA:          // CMP D (Compare A with D)
            uint16_t value = (uint16_t)cpu->A - (uint16_t)cpu->D;
            update_byte_SZAP(cpu, value);
            update_byte_CY(cpu, value);
            break;
        case 0xBB:          // CMP E (Compare A with E)
            uint16_t value = (uint16_t)cpu->A - (uint16_t)cpu->E;
            update_byte_SZAP(cpu, value);
            update_byte_CY(cpu, value);
            break;
        case 0xBC:          // CMP H (Compare A with H)
            uint16_t value = (uint16_t)cpu->A - (uint16_t)cpu->H;
            update_byte_SZAP(cpu, value);
            update_byte_CY(cpu, value);
            break;
        case 0xBD:          // CMP L (Compare A with L)
            uint16_t value = (uint16_t)cpu->A - (uint16_t)cpu->L;
            update_byte_SZAP(cpu, value);
            update_byte_CY(cpu, value);
            break;
        case 0xBE:          // CMP M (Compare A with memory at HL)
            uint16_t address = (cpu->H << 8) | cpu->L;
            uint16_t value = (uint16_t)cpu->A - (uint16_t)read_memory(address);
            update_byte_SZAP(cpu, value);
            update_byte_CY(cpu, value);
            break;
        case 0xBF:          // CMP A (Compare A with A)
            uint16_t value = (uint16_t)cpu->A - (uint16_t)cpu->A;
            update_byte_SZAP(cpu, value);
            update_byte_CY(cpu, value);
            break;

        

        case 0xC0:          // RNZ (Return if not zero)
            if (cpu->flags->Z == 0) {
                ret(cpu);
                opcode_size = 0;
            }
            break;
        case 0xC1:          // POP B (Pop two bytes from stack into BC)
            cpu->C = read_memory(cpu->SP);
            cpu->B = read_memory(cpu->SP + 1);
            cpu->SP += 2;
            break;
        case 0xC2:          // JNZ adr (Jump if not zero)
            if (cpu->flags->Z == 0) {
                uint16_t address = read_word(cpu->PC + 1);
                cpu->PC = address;
                opcode_size = 0;
            } else {
                opcode_size = 3;
            }
            break;
        case 0xC3:          // JMP adr (Jump unconditionally)
            uint16_t address = read_word(cpu->PC + 1);
            cpu->PC = address;
            opcode_size = 0;
            break;
        case 0xC4:          // CNZ adr (Call if not zero)
            if (cpu->flags->Z == 0) {
                uint16_t address = read_word(cpu->PC + 1);
                call(cpu, address);
                opcode_size = 0;
            } else {
                opcode_size = 3;
            }
            break;
        case 0xC5:          // PUSH B (Push BC onto the stack)
            write_memory(cpu->SP - 2, cpu->C);
            write_memory(cpu->SP - 1, cpu->B);
            cpu->SP -= 2;
            break;
        case 0xC6:          // ADI byte (Add immediate to A)
            uint16_t answer = (uint16_t)cpu->A + (uint16_t)read_memory(cpu->PC + 1);
            update_byte_SZAP(cpu, answer);
            update_byte_CY(cpu, answer);
            cpu->A = answer & 0xff;
            opcode_size = 2;
            break;
        case 0xC8:          // RZ (Return if zero)
            if (cpu->flags->Z == 1) {
                ret(cpu);
                opcode_size = 0;
            }
            break;
        case 0xC9:          // RET (Return from subroutine)
            ret(cpu);
            opcode_size = 0;
            break;
        case 0xCA:          // JZ adr (Jump if zero)
            if (cpu->flags->Z == 1) {
                uint16_t address = read_word(cpu->PC + 1);
                cpu->PC = address;
                opcode_size = 0;
            } else {
                opcode_size = 3;
            }
            break;
        case 0xCC:          // CZ adr (Call if zero)
            if (cpu->flags->Z == 1) {
                uint16_t address = read_word(cpu->PC + 1);
                call(cpu, address);
                opcode_size = 0;
            } else {
                opcode_size = 3;
            }
            break;
        case 0xCD:          // CALL adr (Call subroutine)
            uint16_t address = read_word(cpu->PC + 1);
            call(cpu, address);
            opcode_size = 0;
            break;
        case 0xCE:          // ACI D8 (Add immediate to A with carry)
            uint16_t value = cpu->A + (uint16_t)read_memory(cpu->PC + 1) + cpu->flags->CY;
            update_byte_SZAP(cpu, value);
            update_byte_CY(cpu, value);
            cpu->A = value & 0xff;
            opcode_size = 2;
            break;
        case 0xD0:          // RNC (Return if no carry)
            if (cpu->flags->CY == 0) {
                ret(cpu);
                opcode_size = 0;
            }
            break;
        case 0xD1:          // POP D (Pop two bytes from stack into DE)
            cpu->E = read_memory(cpu->SP);
            cpu->D = read_memory(cpu->SP + 1);
            cpu->SP += 2;
            break;
        case 0xD2:          // JNC adr (Jump if no carry)
            if (cpu->flags->CY == 0) {
                uint16_t address = read_word(cpu->PC + 1);
                cpu->PC = address;
                opcode_size = 0;
            } else {
                opcode_size = 3;
            }
            break;
        case 0xD3:          // OUT D8 (Output A to port)
            uint8_t port = read_memory(cpu->PC + 1);
            if (callbacks->out) {
                callbacks->out(port, cpu->A);
            }
            opcode_size = 2;
            break;
        case 0xD4:          // CNC adr (Call if no carry)
            if (cpu->flags->CY == 0) {
                uint16_t address = read_word(cpu->PC + 1);
                call(cpu, address);
                opcode_size = 0;
            } else {
                opcode_size = 3;
            }
            break;
        case 0xD5:          // PUSH D (Push DE onto the stack)
            write_memory(cpu->SP - 2, cpu->E);
            write_memory(cpu->SP - 1, cpu->D);
            cpu->SP -= 2;
            break;
        case 0xD6:          // SUI D8 (Subtract immediate from A)
            uint8_t data = read_memory(cpu->PC + 1);
            uint16_t value = (uint16_t)cpu->A - (uint16_t)data;
            update_byte_SZAP(cpu, value);
            update_byte_CY(cpu, value);
            cpu->A = value & 0xff;
            opcode_size = 2;
            break;
        case 0xD8:          // RC (Return if carry)
            if (cpu->flags->CY == 1) {
                ret(cpu);
                opcode_size = 0;
            }
            break;
        case 0xDA:          // JC adr (Jump if carry)
            if (cpu->flags->CY == 1) {
                uint16_t address = read_word(cpu->PC + 1);
                cpu->PC = address;
                opcode_size = 0;
            } else {
                opcode_size = 3;
            }
            break;
        case 0xDB:          // IN D8 (Input to A from port)
            uint8_t port = read_memory(cpu->PC + 1);
            if (callbacks->in) {
                cpu->A = callbacks->in(port);
            }
            opcode_size = 2;
            break;
        case 0xDC:          // CC adr (Call if carry)
            if (cpu->flags->CY == 1) {
                uint16_t address = read_word(cpu->PC + 1);
                call(cpu, address);
                opcode_size = 0;
            } else {
                opcode_size = 3;
            }
            break;
        case 0xDE:          // SBI D8 (Subtract immediate from A with borrow)
            uint8_t data = read_memory(cpu->PC + 1);
            uint16_t value = (uint16_t)cpu->A - (uint16_t)data - cpu->flags->CY;
            update_byte_SZAP(cpu, value);
            update_byte_CY(cpu, value);
            cpu->A = value & 0xff;
            opcode_size = 2;
            break;
        case 0xE0:          // RPO (Return if parity odd)
            if (cpu->flags->P == 0) {
                ret(cpu);
                opcode_size = 0;
            }
            break;
        case 0xE1:          // POP H (Pop two bytes from stack into HL)
            cpu->L = read_memory(cpu->SP);
            cpu->H = read_memory(cpu->SP + 1);
            cpu->SP += 2;
            break;
        case 0xE2:          // JPO (Jump if parity odd)
            if (cpu->flags->P == 0) {
                uint16_t address = read_word(cpu->PC + 1);
                cpu->PC = address;
                opcode_size = 0;
            } else {
                opcode_size = 3;
            }
            break;
        case 0xE3:          // XTHL (Exchange HL with top of stack)
            uint8_t l = cpu->L;
            uint8_t h = cpu->H;
            cpu->L = read_memory(cpu->SP);
            cpu->H = read_memory(cpu->SP + 1);
            write_memory(cpu->SP, l);
            write_memory(cpu->SP + 1, h);
            break;
        case 0xE4:          // CPO adr (Call if parity odd)
            if (cpu->flags->P == 0) {
                uint16_t address = read_word(cpu->PC + 1);
                call(cpu, address);
                opcode_size = 0;
            } else {
                opcode_size = 3;
            }
            break;
        case 0xE5:          // PUSH H (Push HL onto the stack)
            write_memory(cpu->SP - 2, cpu->L);
            write_memory(cpu->SP - 1, cpu->H);
            cpu->SP -= 2;
            break;
        case 0xE6:          // ANI D8 (AND immediate with A)
            uint16_t value = cpu->A & read_memory(cpu->PC + 1);
            update_byte_SZAP(cpu, value);
            update_byte_CY(cpu, value);
            cpu->A = value & 0xff;
            opcode_size = 2;
            break;
        case 0xE8:          // RPE (Return if parity even)
            if (cpu->flags->P == 1) {
                ret(cpu);
                opcode_size = 0;
            }
            break;
        case 0xE9:          // PCHL (Load PC with HL)
            cpu->PC = (cpu->H << 8) | cpu->L;
            opcode_size = 0;
            break;
        case 0xEA:          // JPE adr (Jump if parity even)
            if (cpu->flags->P == 1) {
                uint16_t address = read_word(cpu->PC + 1);
                cpu->PC = address;
                opcode_size = 0;
            } else {
                opcode_size = 3;
            }
            break;
        case 0xEB:          // XCHG (Exchange DE with HL)
            util_swap(cpu->H, cpu->D);
            util_swap(cpu->L, cpu->E);
            break;
        case 0xEC:          // CPE adr (Call if parity even)
            if (cpu->flags->P == 1) {
                uint16_t address = read_word(cpu->PC + 1);
                call(cpu, address);
                opcode_size = 0;
            } else {
                opcode_size = 3;
            }
            break;
        case 0xEE:          // XRI (XOR immediate with A)
            cpu->A ^= read_memory(cpu->PC + 1);
            update_byte_SZAP(cpu, cpu->A);
            update_byte_CY(cpu, cpu->A);
            opcode_size = 2;
            break;
        case 0xF0:          // RP (Return if positive)
            if (cpu->flags->S == 0) {
                ret(cpu);
                opcode_size = 0;
            }
            break;
        case 0xF1:          // POP PSW (Pop two bytes from stack into flags and A)
            uint8_t flags = read_memory(cpu->SP);
            cpu->flags = *reinterpret_cast<Flags*>(&flags);
            cpu->A = read_memory(cpu->SP + 1);
            cpu->SP += 2;
            break;
        case 0xF2:          // JP (Jump if positive)
            if (cpu->flags->S == 0) {
                uint16_t address = read_word(cpu->PC + 1);
                cpu->PC = address;
                opcode_size = 0;
            } else {
                opcode_size = 3;
            }
            break;
        case 0xF4:          // CP (Call if positive)
            if (cpu->flags->S == 0) {
                uint16_t address = read_word(cpu->PC + 1);
                call(cpu, address);
                opcode_size = 0;
            } else {
                opcode_size = 3;
            }
            break;
        case 0xF5:          // PUSH PSW (Push flags and A onto stack)
            write_memory(cpu->SP - 2, *reinterpret_cast<uint8_t*>(&cpu->flags));
            write_memory(cpu->SP - 1, cpu->A);
            cpu->SP -= 2;
            break;
        case 0xF6:          // ORI D8 (OR immediate with A)
            uint8_t data = read_memory(cpu->PC + 1);
            uint8_t value = cpu->A | data;
            update_byte_SZAP(cpu, value);
            update_byte_CY(cpu, value);
            cpu->A = value;
            opcode_size = 2;
            break;
        case 0xF8:          // RM (Return if minus)
            if (cpu->flags->S == 1) {
                ret(cpu);
                opcode_size = 0;
            }
            break;
        case 0xF9:          // SPHL (Load SP with HL)
            cpu->SP = (cpu->H << 8) | cpu->L;
            break;
        case 0xFA:          // JM (Jump if minus)
            if (cpu->flags->S == 1) {
                uint16_t address = read_word(cpu->PC + 1);
                cpu->PC = address;
                opcode_size = 0;
            } else {
                opcode_size = 3;
            }
            break;
        case 0xFB:          // EI (Enable interrupts)
            cpu->interrupts_enabled = true;
            break;
        case 0xFC:          // CM (Call if minus)
            if (cpu->flags->S == 1) {
                uint16_t address = read_word(cpu->PC + 1);
                call(cpu, address);
                opcode_size = 0;
            } else {
                opcode_size = 3;
            }
            break;
        case 0xFE:          // CPI D8 (Compare A with immediate)
            uint16_t value = (uint16_t)cpu->A - (uint16_t)read_memory(cpu->PC + 1);
            update_byte_SZAP(cpu, value);
            update_byte_CY(cpu, value);
            opcode_size = 2;
            break;


        default:
            printf("Unknown opcode: 0x%02X at address 0x%04X\n", opcode, cpu->PC);
            error("");
            break;
    }
}

void CPU::ret() {
	uint8_t pclo = readMemory(state.sp);
	uint8_t pchi = readMemory(state.sp + 1);
	state.pc = util::makeWord(pchi, pclo);
	state.sp += 2;
}